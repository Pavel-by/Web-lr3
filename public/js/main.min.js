"use strict";

class Dispatcher {
  constructor() {
    this._listeners = {};
  }

  on(type, callback) {
    if (typeof callback !== 'function') return;
    if (this._listeners[type] === undefined) this._listeners[type] = [];

    this._listeners[type].push(callback);
  }

  dispatch(type, event) {
    if (this._listeners[type] === undefined) return;

    this._listeners[type].forEach(listener => listener(event));
  }

}
"use strict";

const utils = {
  toNumber: function (newValue, defaultValue) {
    if (typeof newValue === 'string') newValue = parseFloat(newValue);
    if (typeof newValue === 'number') return newValue;
    return defaultValue;
  },
  toBoolean: function (newValue, defaultValue) {
    if (typeof newValue === 'boolean') return newValue;
    return defaultValue;
  },
  toDate: function (newValue, defaultValue) {
    if (typeof newValue === 'string') newValue = new Date(newValue);
    return newValue || defaultValue;
  }
};
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Auction {
  constructor(other) {
    _defineProperty(this, "_id", void 0);

    _defineProperty(this, "title", void 0);

    _defineProperty(this, "selltimeout", void 0);

    _defineProperty(this, "inputpause", void 0);

    _defineProperty(this, "starttime", void 0);

    _defineProperty(this, "endtime", void 0);

    _defineProperty(this, "pictures", void 0);

    this.update(other);
  }

  update(other) {
    this._id = other._id || this._id;
    this.title = other.title || this.title;
    this.inputpause = other.inputpause || this.inputpause;
    this.selltimeout = other.selltimeout || this.selltimeout;
    this.pictures = other.pictures || this.pictures;
    if (typeof other.starttime === 'string') this.starttime = new Date(other.starttime);else this.starttime = other.starttime || this.starttime;
    if (typeof other.endtime === 'string') this.endtime = new Date(other.endtime);else this.endtime = other.endtime || this.endtime;
  }

}
"use strict";

const auctionService = {
  UPDATE: 'update',
  _dispatcher: new Dispatcher(),
  _data: null,
  refresh: async function () {
    try {
      let rawData = await $.getJSON('/data/auction');
      this._data = new Auction(rawData);

      this._dispatcher.dispatch('update', this);

      return true;
    } catch (e) {
      return false;
    }
  },
  auction: async function () {
    if (this._data == null) await this.refresh();
    return this._data;
  },
  on: function (type, callback) {
    this._dispatcher.on(type, callback);
  },
  save: async function (auction) {
    try {
      let data = JSON.stringify(auction);
      await $.ajax({
        url: '/data/auction',
        contentType: "application/json",
        type: 'PUT',
        data: data
      });
      await this.refresh();
      return true;
    } catch (e) {
      console.log(e);
      return false;
    }
  }
};
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class File {
  constructor(fields) {
    _defineProperty(this, "_id", void 0);

    _defineProperty(this, "originalname", void 0);

    _defineProperty(this, "filename", void 0);

    _defineProperty(this, "mimetype", void 0);

    this.update(fields);
  }

  update(fields) {
    this._id = fields._id;
    this.originalname = fields.originalname;
    this.filename = fields.filename;
    this.mimetype = fields.mimetype;
  }

}
"use strict";

const fileService = {
  CHANGED: "changed",
  _files: null,
  _dispatcher: new Dispatcher(),
  refresh: async function () {
    try {
      this._files = await $.getJSON('/data/file');

      this._dispatcher.dispatch(this.CHANGED, this);

      return true;
    } catch (e) {
      return false;
    }
  },
  findById: async function (id) {
    let files = await this.findAll();
    return files === null || files === void 0 ? void 0 : files.find(file => file._id === id);
  },
  findAll: async function () {
    if (this._files == null) await this.refresh();
    return this._files;
  },
  upload: async function (data) {
    try {
      await $.ajax({
        url: "/data/file",
        contentType: false,
        processData: false,
        data: data,
        type: "PUT",
        dataType: "json"
      });
      await this.refresh();
      return true;
    } catch (e) {
      return false;
    }
  },
  remove: async function (id) {
    try {
      await $.delete(`/data/file/${id}`);
      await this.refresh();
      return true;
    } catch (e) {
      return false;
    }
  },
  on: function (type, callback) {
    this._dispatcher.on(type, callback);
  }
};
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Picture {
  constructor(other) {
    _defineProperty(this, "_id", void 0);

    _defineProperty(this, "title", void 0);

    _defineProperty(this, "description", void 0);

    _defineProperty(this, "author", void 0);

    _defineProperty(this, "filename", void 0);

    _defineProperty(this, "price", void 0);

    this.update(other);
  }

  update(other) {
    if (!other) return;
    this._id = other._id || this._id;
    this.title = other.title || this.title;
    this.description = other.description || this.description;
    this.author = other.author || this.author;
    this.filename = other.filename || this.filename;
    if (this.price != null) this.price.update(other.price || {});else this.price = new PicturePrice(other.price);
  }

}

class PicturePrice {
  constructor(other) {
    _defineProperty(this, "start", void 0);

    _defineProperty(this, "minstep", void 0);

    _defineProperty(this, "maxstep", void 0);

    this.update(other);
  }

  update(other) {
    if (other == null) return;
    this.start = other.start;
    this.minstep = other.minstep;
    this.maxstep = other.maxstep;
    if (typeof this.start === 'string') this.start = parseFloat(this.start);
    if (typeof this.minstep === 'string') this.minstep = parseFloat(this.minstep);
    if (typeof this.maxstep === 'string') this.maxstep = parseFloat(this.maxstep);
  }

}
"use strict";

const pictureService = {
  CHANGED: 'changed',
  _pictures: null,
  _dispatcher: new Dispatcher(),
  refresh: async function () {
    try {
      let data = await $.getJSON('/data/picture');
      this._pictures = data.map(picture => new Picture(picture));

      this._dispatcher.dispatch(this.CHANGED, this);

      return true;
    } catch (e) {
      return false;
    }
  },
  findAll: async function () {
    if (this._pictures == null) await this.refresh();
    return this._pictures;
  },
  findById: async function (id) {
    var _this$_pictures;

    if (this._pictures == null) await this.refresh();
    return (_this$_pictures = this._pictures) === null || _this$_pictures === void 0 ? void 0 : _this$_pictures.find(p => p._id === id);
  },
  upload: async function (data) {
    try {
      await $.ajax({
        url: '/data/picture',
        contentType: "application/json",
        type: 'PUT',
        data: JSON.stringify(data)
      });
      await this.refresh();
      return true;
    } catch (e) {
      return false;
    }
  },
  update: async function (id, data) {
    try {
      await $.ajax({
        url: `/data/picture/${id}`,
        contentType: "application/json",
        type: 'PUT',
        data: JSON.stringify(data)
      });
      await this.refresh();
      return true;
    } catch (e) {
      return false;
    }
  },
  remove: async function (id) {
    try {
      await $.ajax({
        url: `/data/picture/${id}`,
        type: 'DELETE'
      });
      await this.refresh();
      return true;
    } catch (e) {
      return false;
    }
  },
  on: function (type, callback) {
    this._dispatcher.on(type, callback);
  }
};
"use strict";

const authService = {
  LOGIN: "login",
  LOGOUT: "logout",
  _userId: null,
  _synchronized: false,
  _listeners: {},
  _dispatch: function (type, event) {
    let listeners = this._listeners[type];
    if (!listeners) return;
    listeners.forEach(listener => listener(this));
  },
  _synchronizeIfNeed: async function () {
    if (!this._synchronized) await this._synchronize();
  },
  _synchronize: async function () {
    try {
      let user = await $.getJSON('/data/user/me');
      this._userId = user._id;
    } catch (e) {
      this._userId = null;
    } finally {
      this._synchronized = true;
    }
  },
  login: async function (data) {
    try {
      let user = await $.post('/login', data);
      this._userId = user._id;

      this._dispatch(this.LOGIN, this);

      return true;
    } catch (e) {
      console.log(e);
      return false;
    }
  },
  register: async function (data) {
    try {
      let user = await $.post('/register', data);
      this._userId = user._id;

      this._dispatch(this.LOGIN, this);

      return true;
    } catch (e) {
      console.log(e);
      return false;
    }
  },
  logout: async function () {
    try {
      await $.post('/logout');
      this._userId = null;

      this._dispatch(this.LOGOUT, this);

      return true;
    } catch (e) {
      return false;
    }
  },
  userId: async function () {
    if (this._userId != null) return this._userId;

    try {
      await this._synchronize();
      return this._userId;
    } catch (e) {
      return null;
    }
  },
  user: async function () {
    let userId = await this.userId();
    return userId !== null ? userService.findById(userId) : null;
  },
  isLoggedIn: async function () {
    return (await this.userId()) != null;
  },
  addEventListener: function (type, listener) {
    if (typeof listener !== 'function') return;
    if (!this._listeners[type]) this._listeners[type] = [];

    this._listeners[type].push(listener);
  }
};
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class User {
  constructor(fields) {
    _defineProperty(this, "_id", void 0);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "login", void 0);

    _defineProperty(this, "password", void 0);

    _defineProperty(this, "money", void 0);

    _defineProperty(this, "isadmin", void 0);

    _defineProperty(this, "isparticipant", void 0);

    if (!fields) return;
    this.update(fields);
  }

  update(other) {
    if (!other) return;
    this._id = other._id || this._id;
    this.name = other.name || this.name;
    this.login = other.login || this.login;
    this.password = other.password || this.password;
    this.money = utils.toNumber(other.money, this.money);
    this.isadmin = utils.toBoolean(other.isadmin, this.isadmin);
    this.isparticipant = utils.toBoolean(other.isparticipant, this.isparticipant);
  }

}
"use strict";

const userService = {
  CHANGED: 'changed',
  _dispatcher: new Dispatcher(),
  _users: null,
  findById: async function (id) {
    var _this$_users;

    if (this._users === null) await this.refreshAll();
    return ((_this$_users = this._users) === null || _this$_users === void 0 ? void 0 : _this$_users.find(user => user._id === id)) || null;
  },
  findAll: async function () {
    if (this._users === null) await this.refreshAll();
    return this._users;
  },
  refreshAll: function () {
    return new Promise(resolve => {
      $.getJSON('/data/user').done(data => {
        this._users = data.map(json => new User(json));

        this._dispatcher.dispatch(this.CHANGED, this);

        resolve(true);
      }).fail(() => {
        resolve(false);
      });
    });
  },
  on: function (type, callback) {
    this._dispatcher.on(type, callback);
  },
  update: async function (user) {
    try {
      await $.ajax({
        url: `/data/user/${user._id}`,
        contentType: "application/json",
        type: 'PUT',
        data: JSON.stringify(user)
      });
      await this.refreshAll();
      return true;
    } catch (e) {
      return false;
    }
  }
};